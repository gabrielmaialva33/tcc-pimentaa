import 'package:mongo_dart/mongo_dart.dart';
import '../../../core/database/mongodb_client.dart';
import '../../../core/database/mongodb_config.dart';
import '../models/analysis_document.dart';
import '../../analysis/models/analysis_result.dart';

/// Reposit√≥rio para opera√ß√µes CRUD de an√°lises no MongoDB
class AnalysisRepository {
  static AnalysisRepository? _instance;
  static AnalysisRepository get instance => _instance ??= AnalysisRepository._();
  
  AnalysisRepository._();
  
  final MongoDBClient _client = MongoDBClient.instance;
  
  /// Obt√©m a cole√ß√£o de an√°lises
  DbCollection get _collection => _client.getCollection(MongoDBConfig.analysesCollection);
  
  /// Cria uma nova an√°lise
  Future<AnalysisDocument> create(AnalysisDocument analysis) async {
    return await _client.executeWithRetry(() async {
      print('üíæ [ANALYSIS_REPO] Criando nova an√°lise para mem√≥ria: ${analysis.memoryIdString}');
      
      if (!analysis.isValid) {
        throw MongoDBException('Dados da an√°lise s√£o inv√°lidos');
      }
      
      final data = analysis.toMongo();
      final result = await _collection.insertOne(data);
      
      if (result.isSuccess && result.insertedId != null) {
        final createdAnalysis = analysis.copyWith(id: result.insertedId);
        print('‚úÖ [ANALYSIS_REPO] An√°lise criada com ID: ${createdAnalysis.idString}');
        return createdAnalysis;
      } else {
        throw MongoDBException('Falha ao criar an√°lise: ${result.writeError?.errmsg}');
      }
    });
  }
  
  /// Cria an√°lise a partir de AnalysisResult
  Future<AnalysisDocument> createFromResult({
    required AnalysisResult result,
    required String memoryId,
    required String userId,
    String? deviceId,
  }) async {
    print('üíæ [ANALYSIS_REPO] Convertendo AnalysisResult para documento');
    
    final document = AnalysisDocument.fromAnalysisResult(
      result: result,
      memoryId: memoryId,
      userId: userId,
      deviceId: deviceId,
    );
    
    return await create(document);
  }
  
  /// Busca an√°lise por ID
  Future<AnalysisDocument?> findById(String id) async {
    return await _client.executeWithRetry(() async {
      print('üîç [ANALYSIS_REPO] Buscando an√°lise por ID: $id');
      
      final filter = MongoDBHelper.idFilter(id);
      final result = await _collection.findOne(filter);
      
      if (result != null) {
        final analysis = AnalysisDocument.fromMongo(result);
        print('‚úÖ [ANALYSIS_REPO] An√°lise encontrada: ${analysis.idString}');
        return analysis;
      } else {
        print('‚ùå [ANALYSIS_REPO] An√°lise n√£o encontrada: $id');
        return null;
      }
    });
  }
  
  /// Busca an√°lise por mem√≥ria
  Future<AnalysisDocument?> findByMemoryId(String memoryId) async {
    return await _client.executeWithRetry(() async {
      print('üîç [ANALYSIS_REPO] Buscando an√°lise da mem√≥ria: $memoryId');
      
      final filter = {
        'memoryId': MongoDBHelper.stringToObjectId(memoryId),
        'isDeleted': false,
      };
      
      final result = await _collection.findOne(filter);
      
      if (result != null) {
        final analysis = AnalysisDocument.fromMongo(result);
        print('‚úÖ [ANALYSIS_REPO] An√°lise encontrada: ${analysis.idString}');
        return analysis;
      } else {
        print('‚ùå [ANALYSIS_REPO] An√°lise n√£o encontrada para mem√≥ria: $memoryId');
        return null;
      }
    });
  }
  
  /// Busca an√°lises por usu√°rio com filtros opcionais
  Future<List<AnalysisDocument>> findByUser(
    String userId, {
    AnalysisFilter? filter,
    int page = 1,
    int limit = 20,
    Map<String, dynamic>? sort,
  }) async {
    return await _client.executeWithRetry(() async {
      print('üîç [ANALYSIS_REPO] Buscando an√°lises do usu√°rio: $userId (p√°gina $page)');
      
      // Combinar filtro de usu√°rio com filtros adicionais
      final mongoFilter = (filter ?? AnalysisFilter(userId: userId)).toMongoFilter();
      if (filter?.userId == null) {
        mongoFilter['userId'] = userId;
      }
      
      // Configurar pagina√ß√£o e ordena√ß√£o
      final options = MongoDBHelper.paginationOptions(
        page: page,
        limit: limit,
        sort: sort ?? {'createdAt': -1}, // Mais recentes primeiro
      );
      
      final cursor = _collection.find(
        mongoFilter,
        skip: options['skip'],
        limit: options['limit'],
      );
      
      if (options['sort'] != null) {
        cursor.sortBy(options['sort']);
      }
      
      final results = await cursor.toList();
      final analyses = results.map((doc) => AnalysisDocument.fromMongo(doc)).toList();
      
      print('‚úÖ [ANALYSIS_REPO] Encontradas ${analyses.length} an√°lises');
      return analyses;
    });
  }
  
  /// Busca an√°lises por provedor
  Future<List<AnalysisDocument>> findByProvider(
    String userId,
    String provider, {
    int page = 1,
    int limit = 20,
  }) async {
    return await _client.executeWithRetry(() async {
      print('üîç [ANALYSIS_REPO] Buscando an√°lises do provedor: $provider');
      
      final filter = {
        'userId': userId,
        'provider': provider,
        'isDeleted': false,
      };
      
      final options = MongoDBHelper.paginationOptions(
        page: page,
        limit: limit,
        sort: {'createdAt': -1},
      );
      
      final cursor = _collection.find(
        filter,
        skip: options['skip'],
        limit: options['limit'],
      ).sortBy({'createdAt': -1});
      
      final results = await cursor.toList();
      final analyses = results.map((doc) => AnalysisDocument.fromMongo(doc)).toList();
      
      print('‚úÖ [ANALYSIS_REPO] Encontradas ${analyses.length} an√°lises do provedor "$provider"');
      return analyses;
    });
  }
  
  /// Busca an√°lises com lembran√ßas encobridoras
  Future<List<AnalysisDocument>> findWithScreenMemories(
    String userId, {
    int page = 1,
    int limit = 20,
  }) async {
    return await _client.executeWithRetry(() async {
      print('üîç [ANALYSIS_REPO] Buscando an√°lises com lembran√ßas encobridoras');
      
      final filter = {
        'userId': userId,
        'screenMemoryIndicators': {'\$ne': [], '\$exists': true},
        'isDeleted': false,
      };
      
      final options = MongoDBHelper.paginationOptions(
        page: page,
        limit: limit,
        sort: {'createdAt': -1},
      );
      
      final cursor = _collection.find(
        filter,
        skip: options['skip'],
        limit: options['limit'],
      ).sortBy({'createdAt': -1});
      
      final results = await cursor.toList();
      final analyses = results.map((doc) => AnalysisDocument.fromMongo(doc)).toList();
      
      print('‚úÖ [ANALYSIS_REPO] Encontradas ${analyses.length} an√°lises com lembran√ßas encobridoras');
      return analyses;
    });
  }
  
  /// Busca an√°lises por mecanismo de defesa
  Future<List<AnalysisDocument>> findByDefenseMechanism(
    String userId,
    String mechanism, {
    int page = 1,
    int limit = 20,
  }) async {
    return await _client.executeWithRetry(() async {
      print('üîç [ANALYSIS_REPO] Buscando an√°lises com mecanismo: $mechanism');
      
      final filter = {
        'userId': userId,
        'defenseMechanisms': mechanism,
        'isDeleted': false,
      };
      
      final options = MongoDBHelper.paginationOptions(
        page: page,
        limit: limit,
        sort: {'createdAt': -1},
      );
      
      final cursor = _collection.find(
        filter,
        skip: options['skip'],
        limit: options['limit'],
      ).sortBy({'createdAt': -1});
      
      final results = await cursor.toList();
      final analyses = results.map((doc) => AnalysisDocument.fromMongo(doc)).toList();
      
      print('‚úÖ [ANALYSIS_REPO] Encontradas ${analyses.length} an√°lises com mecanismo "$mechanism"');
      return analyses;
    });
  }
  
  /// Busca an√°lises recentes
  Future<List<AnalysisDocument>> findRecent(
    String userId, {
    int limit = 10,
    Duration? within,
  }) async {
    return await _client.executeWithRetry(() async {
      print('üîç [ANALYSIS_REPO] Buscando an√°lises recentes do usu√°rio: $userId');
      
      final filter = {
        'userId': userId,
        'isDeleted': false,
      };
      
      // Adicionar filtro de data se especificado
      if (within != null) {
        final cutoffDate = DateTime.now().toUtc().subtract(within);
        filter['createdAt'] = {'\$gte': cutoffDate};
      }
      
      final cursor = _collection.find(filter, limit: limit)
          .sortBy({'createdAt': -1});
      
      final results = await cursor.toList();
      final analyses = results.map((doc) => AnalysisDocument.fromMongo(doc)).toList();
      
      print('‚úÖ [ANALYSIS_REPO] Encontradas ${analyses.length} an√°lises recentes');
      return analyses;
    });
  }
  
  /// Conta an√°lises do usu√°rio
  Future<int> countByUser(String userId, {AnalysisFilter? filter}) async {
    return await _client.executeWithRetry(() async {
      final mongoFilter = (filter ?? AnalysisFilter(userId: userId)).toMongoFilter();
      if (filter?.userId == null) {
        mongoFilter['userId'] = userId;
      }
      
      final count = await _collection.count(mongoFilter);
      print('üìä [ANALYSIS_REPO] Usu√°rio $userId tem $count an√°lises');
      return count;
    });
  }
  
  /// Atualiza uma an√°lise
  Future<AnalysisDocument?> update(String id, AnalysisDocument analysis) async {
    return await _client.executeWithRetry(() async {
      print('üîÑ [ANALYSIS_REPO] Atualizando an√°lise: $id');
      
      if (!analysis.isValid) {
        throw MongoDBException('Dados da an√°lise s√£o inv√°lidos');
      }
      
      final filter = MongoDBHelper.idFilter(id);
      final update = {
        '\$set': {
          ...analysis.toMongo(),
          'updatedAt': DateTime.now().toUtc(),
        }
      };
      
      final result = await _collection.findAndModify(
        query: filter,
        update: update,
        returnNew: true,
      );
      
      if (result != null) {
        final updatedAnalysis = AnalysisDocument.fromMongo(result);
        print('‚úÖ [ANALYSIS_REPO] An√°lise atualizada: ${updatedAnalysis.idString}');
        return updatedAnalysis;
      } else {
        print('‚ùå [ANALYSIS_REPO] An√°lise n√£o encontrada para atualizar: $id');
        return null;
      }
    });
  }
  
  /// Adiciona nota do terapeuta
  Future<bool> addTherapistNote(String id, String note) async {
    return await _client.executeWithRetry(() async {
      print('üìù [ANALYSIS_REPO] Adicionando nota do terapeuta na an√°lise: $id');
      
      final filter = MongoDBHelper.idFilter(id);
      final update = {
        '\$set': {
          'therapistNotes': note,
          'updatedAt': DateTime.now().toUtc(),
        }
      };
      
      final result = await _collection.updateOne(filter, update);
      final success = result.isSuccess && result.nMatched > 0;
      
      if (success) {
        print('‚úÖ [ANALYSIS_REPO] Nota adicionada √† an√°lise: $id');
      } else {
        print('‚ùå [ANALYSIS_REPO] Falha ao adicionar nota √† an√°lise: $id');
      }
      
      return success;
    });
  }
  
  /// Marca an√°lise como deletada (soft delete)
  Future<bool> delete(String id) async {
    return await _client.executeWithRetry(() async {
      print('üóëÔ∏è [ANALYSIS_REPO] Deletando an√°lise: $id');
      
      final filter = MongoDBHelper.idFilter(id);
      final update = {
        '\$set': {
          'isDeleted': true,
          'updatedAt': DateTime.now().toUtc(),
        }
      };
      
      final result = await _collection.updateOne(filter, update);
      final success = result.isSuccess && result.nMatched > 0;
      
      if (success) {
        print('‚úÖ [ANALYSIS_REPO] An√°lise deletada: $id');
      } else {
        print('‚ùå [ANALYSIS_REPO] Falha ao deletar an√°lise: $id');
      }
      
      return success;
    });
  }
  
  /// Obt√©m estat√≠sticas de an√°lises do usu√°rio
  Future<Map<String, dynamic>> getUserStats(String userId) async {
    return await _client.executeWithRetry(() async {
      print('üìä [ANALYSIS_REPO] Obtendo estat√≠sticas do usu√°rio: $userId');
      
      final pipeline = [
        {'\$match': {'userId': userId, 'isDeleted': false}},
        {
          '\$group': {
            '_id': null,
            'totalAnalyses': {'\$sum': 1},
            'totalTokens': {'\$sum': '\$tokenUsage.totalTokens'},
            'avgTokens': {'\$avg': '\$tokenUsage.totalTokens'},
            'providers': {'\$addToSet': '\$provider'},
            'models': {'\$addToSet': '\$modelUsed'},
            'firstAnalysis': {'\$min': '\$createdAt'},
            'lastAnalysis': {'\$max': '\$createdAt'},
            'screenMemoryCount': {
              '\$sum': {
                '\$cond': [
                  {'\$gt': [{'\$size': '\$screenMemoryIndicators'}, 0]},
                  1,
                  0
                ]
              }
            },
            'defenseMechanisms': {'\$push': '\$defenseMechanisms'},
          }
        },
        {
          '\$project': {
            '_id': 0,
            'totalAnalyses': 1,
            'totalTokens': 1,
            'avgTokens': {'\$round': ['\$avgTokens', 0]},
            'providers': 1,
            'models': 1,
            'firstAnalysis': 1,
            'lastAnalysis': 1,
            'screenMemoryCount': 1,
            'screenMemoryPercentage': {
              '\$round': [
                {'\$multiply': [
                  {'\$divide': ['\$screenMemoryCount', '\$totalAnalyses']},
                  100
                ]},
                1
              ]
            },
            'allDefenseMechanisms': {
              '\$reduce': {
                'input': '\$defenseMechanisms',
                'initialValue': [],
                'in': {'\$setUnion': ['\$\$value', '\$\$this']}
              }
            }
          }
        }
      ];
      
      final results = await _collection.aggregateToStream(pipeline).toList();
      
      if (results.isNotEmpty) {
        final stats = results.first;
        print('‚úÖ [ANALYSIS_REPO] Estat√≠sticas obtidas para usu√°rio: $userId');
        return stats;
      } else {
        print('‚ùå [ANALYSIS_REPO] Nenhuma estat√≠stica encontrada para usu√°rio: $userId');
        return {
          'totalAnalyses': 0,
          'totalTokens': 0,
          'avgTokens': 0,
          'providers': [],
          'models': [],
          'firstAnalysis': null,
          'lastAnalysis': null,
          'screenMemoryCount': 0,
          'screenMemoryPercentage': 0.0,
          'allDefenseMechanisms': [],
        };
      }
    });
  }
  
  /// Obt√©m estat√≠sticas por provedor
  Future<Map<String, dynamic>> getProviderStats(String userId) async {
    return await _client.executeWithRetry(() async {
      print('üìä [ANALYSIS_REPO] Obtendo estat√≠sticas por provedor para usu√°rio: $userId');
      
      final pipeline = [
        {'\$match': {'userId': userId, 'isDeleted': false}},
        {
          '\$group': {
            '_id': '\$provider',
            'count': {'\$sum': 1},
            'totalTokens': {'\$sum': '\$tokenUsage.totalTokens'},
            'avgTokens': {'\$avg': '\$tokenUsage.totalTokens'},
            'models': {'\$addToSet': '\$modelUsed'},
            'lastUsed': {'\$max': '\$createdAt'},
          }
        },
        {
          '\$project': {
            'provider': '\$_id',
            '_id': 0,
            'count': 1,
            'totalTokens': 1,
            'avgTokens': {'\$round': ['\$avgTokens', 0]},
            'models': 1,
            'lastUsed': 1,
          }
        },
        {'\$sort': {'count': -1}}
      ];
      
      final results = await _collection.aggregateToStream(pipeline).toList();
      
      print('‚úÖ [ANALYSIS_REPO] Estat√≠sticas por provedor obtidas');
      return {
        'providers': results,
        'totalProviders': results.length,
      };
    });
  }
  
  /// Busca padr√µes de uso temporal
  Future<List<Map<String, dynamic>>> getUsagePatterns(
    String userId, {
    Duration period = const Duration(days: 30),
  }) async {
    return await _client.executeWithRetry(() async {
      print('üìä [ANALYSIS_REPO] Analisando padr√µes de uso dos √∫ltimos ${period.inDays} dias');
      
      final startDate = DateTime.now().toUtc().subtract(period);
      
      final pipeline = [
        {
          '\$match': {
            'userId': userId,
            'isDeleted': false,
            'createdAt': {'\$gte': startDate},
          }
        },
        {
          '\$group': {
            '_id': {
              'year': {'\$year': '\$createdAt'},
              'month': {'\$month': '\$createdAt'},
              'day': {'\$dayOfMonth': '\$createdAt'},
            },
            'count': {'\$sum': 1},
            'tokens': {'\$sum': '\$tokenUsage.totalTokens'},
            'providers': {'\$addToSet': '\$provider'},
          }
        },
        {
          '\$project': {
            'date': {
              '\$dateFromParts': {
                'year': '\$_id.year',
                'month': '\$_id.month',
                'day': '\$_id.day',
              }
            },
            '_id': 0,
            'count': 1,
            'tokens': 1,
            'providersCount': {'\$size': '\$providers'},
          }
        },
        {'\$sort': {'date': 1}}
      ];
      
      final results = await _collection.aggregateToStream(pipeline).toList();
      
      print('‚úÖ [ANALYSIS_REPO] Padr√µes de uso obtidos: ${results.length} dias com atividade');
      return results;
    });
  }
  
  /// Executa limpeza de an√°lises antigas deletadas
  Future<int> cleanupDeletedAnalyses({
    Duration olderThan = const Duration(days: 30),
  }) async {
    return await _client.executeWithRetry(() async {
      print('üßπ [ANALYSIS_REPO] Limpando an√°lises deletadas antigas...');
      
      final cutoffDate = DateTime.now().toUtc().subtract(olderThan);
      final filter = {
        'isDeleted': true,
        'updatedAt': {'\$lt': cutoffDate},
      };
      
      final result = await _collection.deleteMany(filter);
      final deletedCount = result.nRemoved;
      
      print('‚úÖ [ANALYSIS_REPO] Removidas $deletedCount an√°lises antigas');
      return deletedCount;
    });
  }
}